const userModel = require('../model/UserSchema')
const emailValidator = require("email-validator");
const bycrpt = require('bcrypt');
const signup = async (req, res, next) => {
    const { name, email, password, confirmPassword } = req.body;
    if (!name || !email, !password, !confirmPassword) {
        return res.status(400).json({
            success: false,
            message: "Every field is required"
        })
    }
    const validEmail = emailValidator.validate(email);
    if (!validEmail) {
        return res.status(400).json({
            success: false,
            message: "Please provide a valid email id"
        })
    }
    if (password !== confirmPassword) {
        return res.status(400).json({
            success: false,
            message: "password and confirm password must be same"
        })
    }
    try {
        const userInfo = userModel(req.body) // creates a new instance of the userModel using the data from req.body. This instance, userInfo, is not saved in the database yet; it's just a JavaScript object that represents a user. As data from body have same variable name as of schema so we directly provide the req.body, but incase of not same you need to write all
        const result = await userInfo.save(); // .save inbuilt method of mongoose library to save the document and result is the saved document info
        return res.status(200).json({
            success: true,
            data: result
        })
    }
    catch (e) {
        if (e.code === 11000) { // 11000 is the code for duplicate entry (remember it)
            return res.status(400).json({
                success: false,
                message: 'Duplicate entry not allowed'
            })
        }
        return res.status(400).json({
            success: false,
            message: e.message
        })
    }
}


const signin = async (req, res) => {
    const { email, password } = req.body;
    if (!email || !password) {
        return res.status(400).json({
            success: false,
            message: "Every field is mandatory"
        })
    }


    try {
        const user = await userModel
            .findOne({ email })
            .select("+password");
        // if (!user || user.password !== password) { 
            if (!user || ! (await bycrpt.compare(password,user.password))) { //bcrypt because we encripted the password obn saving time
            return res.status(400).json({   // note: if await is not used in above bycrpt.compare then it always returns true hence above if condition never work
                success: false,
                message: "Invalid credentials"
            })
        }

        // if email and password are verified then we generate token of it and save it to cookie
        /*token is generated in 3 parts:
        1.which alogorithm we used
        2. what data we want to store
        3. which secreate/signature key is used for encription
        */

        const token = user.jwtToken();  // not a issue that here we make password undefined after making token because token is only generated by id and email which are payload, a secrete key and a expiry which are defined in user schema method
        user.password = undefined; // so that password not leek

        const cookieOption = {
            maxAge: 24 * 60 * 60 * 1000, //24h validity
            httpOnly: true // means client side se access nhi hogi provide security
        }
        res.cookie("token", token, cookieOption) //cookie name: token, token, optional options
        res.status(200).json({
            success: true,
            data: user //password not shared
        })
    } catch (e) {
        res.status(400).json({
            success: false,
            message: e.message
        })
    }
}


const getUser = async (req, res) => {
    userId = req.user.id;
    try {
        const user = await userModel.findById(userId)
        return res.status(200).json({
            success: true,
            data: user // no password will be seen
        })
    } catch (error) {
        return res.status(400).json({
            success: false,
            message: error.message
        })
    }
}

const logout = (req, res)=>{// to logout we delete the cookie
    try {
        const cookieOption= {
            expires: new Date(),
            httpOnly: true
        }
        res.cookie("token", null, cookieOption);
        res.status(200).json({
            success: true, 
            message: "Loggout"
        })
    } catch (error) {
        res.status(400).json({
            success: false,
            message:e.message
        })
    }
}


module.exports = {
    signup,
    signin,
    getUser,
    logout
}